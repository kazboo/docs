# 1 CPUの使用率

* CPUの使用率とJavaプログラムにとっての意味

* CPUの使用率は`ユーザー時間`と`システム時間`の２つに分類できる
  * Windowsではシステム時間を`特権時間(privileged time)`

* ユーザ時間
  * CPUがアプリケーションのコードを実行している時間の割合を表す

* システム時間
  * CPUがOSのカーネルのコードを実行している時間の割合を表す
  * アプリケーションと無関係ではない
    * アプリケーションが入出力を行った場合、以下のコードを実行する
      * カーネルはファイルをディスクから読み出す
      * バッファーに保持されているデータをネットワークに送り込む
      * etc
    * システムリソースを使うプログラムで、システム時間はより長くなる

* ここで目標は、CPUの使用率を`できるだけ高く`し、その期間を`できるだけ短くすること`
  * CPU使用率100%の状態が`長く続いてしまえば`他のプログラムが実行されるのを
  妨げてしまうことになる
  * CPUの本当の意味について検討する

* CPU使用率の値は`ある一定の期間の平均値`を表しているという点
  * この期間はあいまいで、１秒以上、あるいは３０秒

  * 例）あるプログラムの実行に１０分かかり、その間のCPU使用率が５０％だった
    * １００％にあげるようなチューニングを行えたら、パフォーマンスは２倍になり、５分で実行できる
    * さらにパフォーマンスを２倍にできたとしたら、CPU使用率は１００％のままで実行時間は２分３０秒ということになる
  * CPU使用率とは、`プログラムがどの程度効率的にCPUを使えているか`ということを表す

* `vmstat`
  * [Linux]メモリーやCPUの負荷率や使用状況を表示する
  ``` cmd
  vmstat （オプション）［時間間隔 ［回数］］
  ```
  ``` cmd
  メモリーやCPUの情報を1秒間隔で3回表示する
  $ vmstat 1 3 
  procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
   r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
   2  0      0   6608   6796 192804    0    0     0     9  548  569 41  3 55  0  0
   2  0      0   5764   6828 192836    0    0     0     8 1090 1576 43  3 54  0  0
   1  0      0   7092   6844 191284    0    0     3    22 1085 1510 42  3 55  0  0
   1  0      0   7092   6844 191284    0    0     0    84 2418 3998 43  2 55  0  0
  ```
  * cpu: CPUの使用量の割合
    * us(user): ユーザ時間の割合
    * sy(system): システム時間の割合
    * id(idle): アイドル時間（CPUが何も処理せずに待っていた時間）の割合 ※I/O待ちは含まない
    * wa(wait): IO待ち時間の割合
    * st(stolen): 仮想マシンに与えた時間の割合
  * 上記例の場合、1秒間の内何割かを表示する
    * 1000(msec) * 0.55 = 550(msec)がアイドル時間
    * 1000 - 550 = 450(msec)がビジー状態
    * アイドルが0%なら、CPU使用率は100%

* `アイドル状態`はどういった状態か
  * アプリケーションにとって行うべき処理がない
  * アプリケーションが何か（例えばデータベースのレスポンス）を待っている
  * 同期プリミティブ（基本機構）でアプリケーションがブロックされ、ロックの解放まで実行が中断されている

## 1.1 Javaと単一CPUの使用率

* 周期的にアイドル状態とは何を意味しているのか
  * アプリケーションの種類ごとに異なる
    * 作業量が一定のバッチ処理
      * 「行うべき処理がない」せいでCPUがアイドル状態になることはない
      * CPUの使用率をあげれば、実行時間を短縮できる
      * すでに100%に達しているのであれば別の最適かを行い実行時間を短縮する
    * クライアントからのリクエストを受け付けるサーバーアプリケーション
      * 「行うべき処理がない」せいでアイドル状態になることがある
        * 次のリクエストを待機する状態等
        * こういった場合に、CPU使用率が`一定期間の平均値`を表すということが意味を成す

* 表は、アプリケーションサーバーに対して１秒間に１回ずつリクエストを送信しながら測定したもの
  * 1つのリクエストを処理するのに約450msecかかっていることがわかる
  * 1秒のうち450msecはCPU使用率が100%で、残りの550msecは0%となる
  * この状態を指して、CPU使用率が45%であると表現している
  * 450msecかかっていた処理を400msecで済ませられるような最適化を行えたら、CPU使用率は40%に減少する
    * この様な場合に限り、CPU使用率を`下げる`事に意味がある
      * `一定量の負荷が間隔をあけて与えられ、かつ外部のリソースの制約を受けない`場合
    * 一方、最適化によってシステムがより多くのリクエストを処理できるようになった場合、CPU使用率が上昇するということも考えられる
    * ほとんどのツールでは、使用率が上昇している時間が短いため、100%と表示されないだけのこと

## 1.2 Javaと複数CPUの使用率

* 例では１つのCPUの上で１つのスレッドが実行されていた
  * 基本的な考え方は複数のCPUの上で複数のスレッドが実行される場合にも当てはまる

* 目指すべきゴールは同様に２つ
  * それぞれのスレッドがブロックされないようにしてCPUの使用率を上げること
  * （長い期間で見た場合の）CPUの使用率を下げてより多くのリクエストを受け付けられるようにすること

* アイドル状態になる重要な条件がもう一つ
  * プログラムの中で処理を行うスレッドが残っていない場合
    * 固定された大きさのスレッドプールが様々な処理を行っている場合等に、この状態に陥ることがある
      * 各スレッドがデータベースからのレスポンス待ちなどでブロック
      * やるべき作業があっても、割り当てるスレッドがない状態
    * こういった場合は、スレッドプールのサイズを増やすべき
      * ただしアイドル状態のCPUがあったら常にスレッドプールを大きくするべきというわけではない
      * 別の理由（ロックのボトルネックと、外部リソース）のせいでプログラムがCPUサイクルを獲得できない可能性があるから
        * 対策を決める前に、CPUが使われていない理由を把握するべき

* CPU使用率を知ることはアプリケーションのパフォーマンスを知るための第一歩だが、これだけがすべてではない

* CPU使用率は以下のことを調べているに過ぎない
  * 期待しうるすべてのCPUサイクルを実際にコードが利用しているかどうか
  * 同期やリソースの問題はないか

## 参考

* [CPU使用率100%は悪なのか？](https://qiita.com/zd6ir7/items/2cb39f55f3b15af79f6f)