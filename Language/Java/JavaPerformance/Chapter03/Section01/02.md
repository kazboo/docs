# 2. CPUのランキュー

* WindowsとUnixのシステムはともに`実行可能なスレッド数を監視するための仕組み`を備えている
  * 実行可能：IO待ちやスリープ中ではないという意味

* Unixではこの仕組みを`ランキュー(run queue, 実行待ち行列)`と呼ぶ
  * この長さを出力するツールもいくつかある
  * vmstat
    * 各行の先頭の数値はランキューの長さを表す
* Windowsでは`プロセッサキュー`と呼ばれる
  * `typeperf`で内容を確認できる
  ``` cmd
  typeperf -si 1 "\System\Processor Queue Length"
  "05/11/2013 19:09:42.678", "0.000000"
  "05/11/2013 19:09:43.678", "0.000000"
  ```

* UnixとWindowsで示す値の意味は異なる
  * Unix
    * 以下の合計値
      * 現在実行中のスレッドの数
      * CPUが利用可能になったらすぐに実行できるスレッドの数
    * ランキューの長さは必ず１以上になる
      * 実行を希望していたスレッドが最低１つ存在する
        * その１つはアプリケーションの処理を行うスレッド
      * ランキューはマシン上で動作しているすべてのものを表す
        * まったく別のプロセスで実行を希望しているスレッドが含まれる場合もある
          * `2`と表示されている行
  * Windows
    * プロセッサキューの長さの中に現在実行中のスレッドの数は含まれない
      * `typeperf`の出力例では`0`が表示される

* 利用可能なCPUよりも多い数のスレッドを実行しなければならない場合パフォーマンスは低下する
  * Windows
    * 一般的にプロセッサキューの長さをゼロにすることが望まれる
  * Unix
    * 一般的にランキューの長さをCPUと同数あるいはそれ以下にすることが望まれる
  * 絶対的な原則ではない
    * システムプロセスやその他のプロセスが時折現れ、ランキューの長さを短い間増加させることがある
      * これによるパフォーマンスの影響はない

* ランキューが長すぎる状態が継続する場合
  * マシンの負荷が高いということを示している
    * マシン上ので行われている処理を減らす必要がある
      * 作業を別のマシンに移動
      * コードを最適化する
      * etc

## ここまでのまとめ

* アプリケーションのパフォーマンスを調べる際には、`まずCPUの使用率を測定する`

* コードを最適化する場合、`目標は（短い時間内での）CPU使用率を上げること`である
  * `下げるのではない`

* アプリケーションのチューニングに取り掛かる`前に`、CPU使用率が`低い理由`を把握する