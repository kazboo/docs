# Reactの流儀

* Steps
    1. UIをコンポーネントの階層構造に落とし込む
    1. Reactで静的なバージョンを作成する
    1. UI状態を表現する必要かつ十分なstateを決定する
    1. stateをどこに配置するべきなのかを明確にする
    1. 逆方向のデータフローを追加する

## モックから始めよう

* JSON API は次のようなデータを返してくるとしましょう
    ```json
    [
    {category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"},
    {category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"},
    {category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"},
    {category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"},
    {category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"},
    {category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"}
    ];
    ```


## Step1:UIをコンポーネントの階層構造に落とし込む

* モックを形作っている各コンポーネント（構成要素）を四角で囲んで、それぞれに名前をつけていくこと
    + Photoshop でレイヤ名にしていた名前が、最終的にはReact コンポーネントの名前になりうる

* 単一のコンポーネントに括るべき範囲を見つける
    + 新しい関数やオブジェクトをいつ作るのかを決めるときと、同じ手法が使える
    + このような手法のひとつに、単一責任の原則 (single responsibility principle) がある
        - ひとつのコンポーネントは理想的にはひとつのことだけをするべきだということ
        - 将来、コンポーネントが肥大化してしまった場合には、小さなコンポーネントに分割するべき

* UI と(JSONの)データモデルが同じ 情報の構造 を持つ傾向がある
    + UI をコンポーネントに切り分ける作業は自明なものになりがち
    + モックを分割して厳密に一部分だけを表現するコンポーネントへ落とし込む
    ![sample](https://ja.reactjs.org/static/thinking-in-react-components-eb8bda25806a89ebdc838813bdfa3601-82965.png)

* 5 種類のコンポーネントがこのシンプルなアプリの中にあることが見て取れる
    1. FilterableProductTable
        + このサンプル全体を含む
    1. SearchBar
        + 全てのユーザー入力を受け付ける
    1. ProductTable
        + ユーザー入力に基づくデータの集合を表示・フィルタする
    1. ProductCategoryRow
        + カテゴリを見出しとして表示する
    1. ProductRow
        + 各商品を1行で表示する

* コンポーネントの階層構造
    * FilterableProductTable
        + SearchBar
        + ProductTable
            - ProductCategoryRow
            - ProductRow

## Step2:Reactで静的なバージョンを作成する

* 最初は、データモデルを受け取って UI の描画だけを行い、ユーザーからの操作はできないというバージョンを作るのが、もっとも簡単

* 表示の実装とユーザ操作の実装を切り離しておくことは重要
    + 静的な（操作できない）バージョンを作る際には、タイプ量が多い代わりに考えることが少ない
    + ユーザ操作を実装するときには、考えることが多い代わりにタイプ量は少ない

* データモデルを描画するだけの機能を持った静的なバージョンのアプリを作る際
    + 他のコンポーネントを再利用しつつそれらに props を通じてデータを渡す形で、自分のコンポーネントを組み上げる
    + props は`親から子へとデータを渡すための手段`
    + あなたが state に慣れ親しんでいる場合でも、今回の静的なバージョンを作る上では`一切 state を使わないでください`
    + state は`ユーザー操作や時間経過などで動的に変化するデータを扱うために確保されている機能`

* 今回のアプリは静的なバージョンなので、state は必要ない

* コンポーネントはトップダウンで作っても、ボトムアップで作っても問題ありません
    + 高い階層にあるコンポーネント（例えば FilterableProductTable）から作り始めてもいい
    + 低い階層にあるコンポーネント（ProductRow など）から作り始めてもいい

* シンプルなアプリでは通常トップダウンで作った方が楽
    + 大きなプロジェクトでは開発をしながらテストを書き、ボトムアップで進める方がより簡単

* このアプリは静的なバージョンなので、コンポーネントは render() メソッドだけを持つことになる
    + 階層構造の中で最上位のコンポーネント（FilterableProductTable）が、データモデルを props として受け取る
    + 元となるデータモデルを更新して再度 ReactDOM.render() を呼び出すと、UI が更新されることになります
    + React の単方向データフロー（あるいは単方向バインディング）により、すべてがモジュール化された高速な状態で保たれる

## Step3:UI状態を表現する必要かつ十分なstateを決定する

* UI をインタラクティブなものにするためには元となっているデータモデルを更新できる必要があります
    + これは React なら state を使うことで容易に実現できます

* 適切に開発を進めていくにあたり、そのアプリに求められている更新可能な状態の最小構成を、最初に考えておいたほうがよい
    + ここで重要なのは、DRY (don’t repeat yourself)の原則
    + アプリケーションが必要としている最小限の状態を把握しておき、他に必要なものが出てきたら、そのとき計算すればよい
    + 例えば、TODO リストを作る場合、TODO の各項目を配列で保持するだけにし、個数のカウント用に別の state 変数を持たないようにします
    + その代わりに、TODO の項目数を表示したいのであれば、単純に配列の length を使えばよいのです

* 今回のサンプルアプリを形作るすべてのデータについて考えてみましょう
    + 元となる商品のリスト
    + ユーザーが入力した検索文字列
    + チェックボックスの値
    + フィルタ済みの商品のリスト

* どれが state になりうるのかを考えてみます
    + 各データについて、3 つの質問をするだけ
        - 親から props を通じて与えられたデータでしょうか？
            - もしそうなら、それは state ではありません
        - 時間経過で変化しないままでいるデータでしょうか？
            - もしそうなら、それは state ではありません
        - コンポーネント内にある他の props や state を使って算出可能なデータでしょうか？
            - もしそうなら、それは state ではありません

* 元となる商品のリストはstate ではありません
    -  props から渡されるのため

* 検索文字列とチェックボックスはstate だと思われます
    - 時間の経過の中で変化し、また算出することもできないため

* 最後に、フィルタ済みの商品のリストは state ではありません
    - 元となる商品のリストと検索文字列とチェックボックスの値を組み合わせることで、フィルタ済みの商品のリストを算出することが可能だから

## Step4:stateをどこに配置するべきなのかを明確にする

* state の最小構成が明確になりました
    + 次は、どのコンポーネントが state を変化させるのか
    + つまり state を所有するのかを明確にしましょう。

* 復習
    + React は、コンポーネントの階層構造をデータが流れ落ちていく、`単方向データフローで成り立っている`
    + も
    しかすると、どのコンポーネントがどんな state を持つべきなのかが、すぐにはわからないかもしれません
    + これは、初学者が React への理解を深める上で、最も難しい問題になりがちなところ 
        - ステップを踏みながら理解していきましょう

* アプリの各 state について、次の各項目を確認していきます。
    + その state を使って表示を行う、すべてのコンポーネントを確認する
    + 共通の親コンポーネントを見つける
        + その階層構造の中で、ある state を必要としているすべてのコンポーネントの上位にある単一のコンポーネントのこと
    + 共通の親コンポーネントか、その階層構造でさらに上位の別のコンポーネントが state を持っているべきである

* state を持つにふさわしいコンポーネントを見つけられなかった場合は、state を保持するためだけの新しいコンポーネントを作る
    + 階層構造の中ですでに見つけておいた共通の親コンポーネントの上に配置する

* それでは、この戦術をサンプルアプリにも適用してみましょう
    + ProductTable は商品リストをフィルタする必要があり、SearchBar は検索文字列とチェック状態を表示する必要がある
    + 共通の親コンポーネントは FilterableProductTable である
    + 概念的にも、検索文字列とチェック状態が FilterableProductTable に配置されることは妥当である


* state を FilterableProductTable の中に配置することが決まりました

* インスタンス変数として this.state = {filterText: '', inStockOnly: false} を FilterableProductTable の constructor に追加
    + 初期状態をアプリに反映

* その次は、filterText と inStockOnly を ProductTable と SearchBar に props として渡す

* 最後に、これらの props を使って ProductTable のフィルタ処理を行い、SearchBar のフォームにも値を埋める

* これで、このアプリがどんな振る舞いをするのか見られるようになってきました
    + filterText に "ball" と入力した状態でアプリを更新すると、データの表が正しく更新されたことが確認できるはず

## Step5:逆方向のデータフローを追加する

* ここまでで、props と state が階層構造を流れ落ちていく関数として、正しく描画を行うアプリを作ることができました

* それでは、別の方向のデータフローもサポートしてみましょう
    
* 階層構造の奥深くにあるフォームのコンポーネントが、FilterableProductTable にある state を更新できるようにするのです

* React ではデータフローが明示的になりプログラムの動作が理解しやすくなりますが、従来の双方向データバインディングよりも少しタイプ量が増えてはしまいます

* 試しに、現在のバージョンのサンプルで文字を打ち込んだり、チェックボックスを切り替えてみると、React がその入力を無視することがわかります
    + これは意図的な挙動で、input の value props が、常に FilterableProductTable から渡された state と同じ値になるようにセットしてあるのです

* それでは、どんな挙動になってほしいのかを考えてみましょう
    + ユーザーがフォームを変更するたびに、ユーザー入力を反映するように state を更新したい
    + コンポーネントの state を更新できるのは自分自身だけであるべきなので、FilterableProductTable は SearchBar にコールバックを渡しておいて、state を更新したいときに実行してもらうようにします
    + 入力のたびに呼び出される onChange イベントを利用するとよいでしょう
    + このコールバックを実行された FilterableProductTable は、setState() を呼び出し、その結果としてアプリが更新される

* これは複雑に思えるかもしれませんが、ほんの数行のコードです

* そして、これらはデータがアプリの中をどのように流れているのかを、明確に示している

## 終わりに

* これで React を使ってコンポーネントやアプリケーションを構築するときの考え方が身に付いたのではないでしょうか

* それはもしかしたら、あなたのこれまでのやり方よりも、多くのコードを書くことになるかもしれません

* しかしながら、コードは書くよりも読むことのほうが多いこと、そしてモジュール化されていて明示的であるコードは非常に読みやすいということを思い出してください

* 大規模なコンポーネントのライブラリを構築し始めると、この明示性やモジュール化しやすさのありがたみが分かり始めます

* そしてコードを再利用できるようになるにつれて、あなたが書くコードの行数は減っていくのです